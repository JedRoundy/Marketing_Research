---
author: Jed Roundy
format: pdf

---
# Install Packages and General Setup
```{r include = FALSE}
library(here)
library(tidyverse)
library(openai)
library(readxl)

source('../api_key.R')

Sys.setenv(
    OPENAI_API_KEY = api_key 
) 
```


# Read in Data
```{r include = FALSE}
filepath <-  here('Yogurt_Conjoint', 'Yogurt Design Grid.xlsx')

d <- read_excel(filepath, sheet = 2)

d <- rename(d, c(brand_num = brand...5, type_num = type...6, fat_num = fat...7, package_num = package...8, price_num = price...9, brand_name = brand...10, type_name = type...11, fat_name = fat...12, package_name = package...13, price_name = price...14))

d <- d |> select(-...1)
```

# Get Responses
```{r include=FALSE}
get_response <- function(n = 5, chat = FALSE, prompt, role, keywords, temp){

  #Change formatting and model based on chat TRUE/FALSE
  if(chat == TRUE){
    model <- 'gpt-3.5-turbo'
    prompt <- list(list('role' = 'system', 'content' = role), list('role' = 'user', 'content' = prompt))
  }
  
  if(chat == FALSE){
    model <- 'text-davinci-003'
  }

  
  #identify model and temperature wanted
  temp <- temp
  tokens <- 100
  

  #Use function based on chat argument
  if(chat == TRUE){
    response <- create_chat_completion(model = model, n = n, messages = prompt, temperature = temp, max_tokens = tokens)
  }
  
  if(chat == FALSE){
  response <- create_completion(model = model, n = n, prompt = prompt, temperature = temp, max_tokens = tokens, best_of = n )
  }
  
  #Create choices object  to access the choices directly
  choices <- response$choices
  
  #Create a text vector to store the text in
  text_v <- c()
  
  #Loop through each choice with appropriate access path
  for (i in 1:n){
    
    if(chat == TRUE){
      text_v <- c(text_v, choices[[4]][[i]])
    }
    
    if(chat == FALSE){
      text_v <- c(text_v, choices[[1]][[i]])
    }
  }
  
  #Create vector to store true/false string comparisons
  answer <- c()
  
  
  #Loop through individual responses
  for (string in text_v){
    
    is_true <- c()
    
    #Loop through the keywords
    for(keyword in keywords){
      
      #Append the is_true vector with the result of keyword search
      is_true <- c(is_true, grepl(keyword, string, ignore.case = TRUE))
    }
  
    #If there is more than 1 keyword found, then return inconclusive. Else, return the keyword that is found. 
    answer <- c(answer, ifelse(sum(is_true) > 1, 'Inconclusive', keywords[is_true]))
  }
  #Makes sure all elements are in a single vector
  answer <- unlist(answer, FALSE)

return(list(answer = answer, text_v = text_v))
#return(answer)  
}
```

# Conjoint Prompt
```{r}

conjoint_prompt <- function(role_num, prompt_num, brand_1, type_1, fat_1, package_1, price_1, brand_2, type_2, fat_2, package_2, price_2){
  
  
  #Standard role
  if(role_num ==1){
  role <- 'You are taking a consumer survey on yogurt, and you are presented with three choices. Two choices will be to purchase an item with given attributes, and a third option to not purchase anything. Please respond with ONLY the option number, i.e. 3,2,1. Do NOT include any other information.'
  }
  
  #Detailed role 1
  if(role_num ==2){
  role <- 'Imagine you are a middle aged, white, woman who is grocery shopping. You find the yogurt isle, but they only have two products. You have the choice to either purchase one of the products, or you can leave without purchasing either product. Below are the options available to you. Please respond with ONLY the option label, i.e. 1,2,3 or A,B,C, etc.'
  }
  
  if (role_num ==3){
    'Imagine you are a young, single, male, college student who is grocery shopping. You find the yogurt isle, but they only have two products. You have the choice to either purchase one of the products, or you can leave without purchasing either product. Below are the options available to you. Please respond with ONLY the option number, i.e. 1, 2, or 3.'
  }
  
  #Standard Prompt
  if(prompt_num ==1){
  prompt <- paste('Option 1: Brand:', brand_1, 'Type:', type_1, 'Fat:', fat_1, 'Packaging:', package_1, 'Price:', price_1, '\n', 'Option 2: Brand:', brand_2, 'Type:', type_2, 'Fat:', fat_2, 'Packaging:', package_2, 'Price:', price_2, '\n', 'Option 3: I would not purchase either of these products.')
  }
  
  
  #Numbers instead of letters
  if(prompt_num ==2){
  prompt <- paste('Option 1: Brand:', brand_2, 'Type:', type_2, 'Fat:', fat_2, 'Packaging:', package_2, 'Price:', price_2, '\n', 'Option 2: Brand:', brand_1, 'Type:', type_1, 'Fat:', fat_1, 'Packaging:', package_1, 'Price:', price_1, '\n', 'Option 3: I would not purchase either of these products.')
  }
  
  #Using letters and numbers
  if(prompt_num == 3) {
    
    prompt <- paste('Option A3: Brand:', brand_2, 'Type:', type_2, 'Fat:', fat_2, 'Packaging:', package_2, 'Price:', price_2, '\n', 'Option B2: Brand:', brand_1, 'Type:', type_1, 'Fat:', fat_1, 'Packaging:', package_1, 'Price:', price_1, '\n', 'Option C1: I would not purchase either of these products.')
    
  }
  
    if(prompt_num == 4) {
    
    prompt <- paste('Option Q: Brand:', brand_1, 'Type:', type_1, 'Fat:', fat_1, 'Packaging:', package_1, 'Price:', price_1, '\n', 'Option G: Brand:', brand_2, 'Type:', type_2, 'Fat:', fat_2, 'Packaging:', package_2, 'Price:', price_2, '\n', 'Option P: I would not purchase either of these products.')
    
  }
  return(c(role, prompt))
}


```


# Get the responses

```{r}
choice_v <- c()
text_v <- c()

#variations on role and prompt
role_num <- 1
prompt_num <- 1

#temperature setting
temperature <- 1

#Number of distinct tests performed
k = 1

#Number of responses per test

n = 30

for (i in seq(1, k*2, by = 2)){
      #For each round, only grab two rows of data at a time 
     task <- d[i:(i+1), ]
     #create list of args for the prompt
    args <- list(prompt_num, task[1,'brand_name'], task[1, 'type_name'], task[1, 'fat_name'], task[1, 'package_name'], task[1, 'price_name'], task[2,'brand_name'], task[2, 'type_name'], task[2, 'fat_name'], task[2, 'package_name'], task[2, 'price_name'])
    
    #Call the prompt with the list of args
    cp <- do.call(conjoint_prompt, args = args)
    #separate the role from the prompt
    role <- cp[1]
    prompt <- cp[2]
    
    #use the get_response function to call the openai api and parse out the responses from the api
    response <- get_response(n = n, chat = TRUE, prompt = prompt, role = role, keywords = c('A3', 'B2','C1'), temp = temperature)
    
    #apply the responses of the choice( via keyword) and text (direct from response) to appropriate vectors
    choice_v <- c(choice_v, unlist(response[1]))
    text_v <- c(text_v, unlist(response[2]))
    
}

choice_v <- rep(choice_v, each = 2)
text_v <- rep(text_v, each = 2)

assign(paste('d_','r_', role_num, 'p_', prompt_num, 't_', temperature), cbind(d[1:n,], choice_v, text_v))

```


Pride Debiasing Algorithm
```
Require: Language model, test samples D = {(q_i, x_i)}_8, option number n, estimation budget K
Ensure: Model predictions y

1. Initialize the model prediction set Y = NULL SET and the prior set P = NULL SET----=> Initialization
2. Sample the estimation samples D_e under K and the remaining samples D_r = D\D_e
3. for (x, x) element of D_e do
4. Debias the model prediction using Eq. 1, add the predicted answer to Y
5. Estimate the sample-specific prior P_prior(d_i|q) using Eq. 7, add it into P
6. End for
7.Estimate the global prior Ptilde_prior(d_i) by averaging P--------------------------=> Prior Estimation
8: for (x,x) element of D_r do
9: Debias the model prediction using Eq. 8, add the predicted answer to Y-------------=> Efficient Debiasing
10: end for
11: return Y

```
Implement Pride

```{r}

#1. Initialize the model prediction set Y = NULL SET and the prior set P = NULL SET----=> Initialization

Y <- list()
P <- list()
#2. Sample the estimation samples D_e under K and the remaining samples D_r = D\D_e

#3. for (x, x) element of D_e do
#4. Debias the model prediction using Eq. 1, add the predicted answer to Y
#5. Estimate the sample-specific prior P_prior(d_i|q) using Eq. 7, add it into P
#6. End for
#7.Estimate the global prior Ptilde_prior(d_i) by averaging P--------------------------=> Prior Estimation
#8: for (x,x) element of D_r do
#9: Debias the model prediction using Eq. 8, add the predicted answer to Y-------------=> Efficient Debiasing
#10: end for
#11: return Y



```


